# TypeScript 迁移技术栈选型报告

## 一、项目对比分析

| 维度 | 参考项目 (claude-mem) | 当前项目 (claude-session-recorder) |
|------|----------------------|-----------------------------------|
| **语言** | TypeScript | Bash/Shell |
| **数据存储** | SQLite 数据库 | JSON 文件 |
| **持久化** | 结构化数据库 | 文件系统 |
| **构建工具** | tsup | 无需构建 |
| **类型系统** | 完整类型定义 | 无 |
| **跨平台** | Node.js 运行时 | Git Bash/原生 Shell |
| **依赖管理** | npm + pnpm | 无外部依赖 |
| **Hook 实现** | TypeScript 编译为 shell | 原生 shell 脚本 |

## 二、核心技术栈

### 2.1 语言与运行时

```typescript
TypeScript 5.x + Node.js 18+
```

**选择理由：**
- TypeScript 提供完整类型系统，提升代码质量和可维护性
- Node.js 18+ 是 LTS 版本，稳定可靠
- 与 Claude Code CLI 插件生态保持一致

### 2.2 打包工具

```typescript
pkg - 将 Node.js 项目打包成独立可执行文件
```

**工具对比：**

| 工具 | 优势 | 劣势 | 推荐度 |
|------|------|------|--------|
| **pkg** | • 成熟稳定<br>• 官方维护<br>• 跨平台支持好<br>• 单文件输出 | • 打包体积较大<br>• 某些原生模块不支持 | ⭐⭐⭐⭐⭐ |
| nexe | • 打包体积小 | • 维护不活跃<br>• Node 版本限制多 | ⭐⭐⭐ |
| node-packer | • 极简 | • 功能受限 | ⭐⭐ |

**最终选择：pkg**

### 2.3 数据存储

**方案选择：JSON 文件**

| 方案 | 优势 | 劣势 | 推荐度 |
|------|------|------|--------|
| **SQLite** | • 结构化查询<br>• 高性能<br>• 数据完整性<br>• 易于扩展 | • 需要原生依赖编译<br>• 迁移复杂度高 | ⭐⭐⭐ |
| **JSON 文件** | • 轻量无依赖<br>• 迁移成本低<br>• 人工可读<br>• 与现有兼容 | • 大文件性能差<br>• 查询能力弱 | ⭐⭐⭐⭐⭐ |

**推荐理由：**
- 保持轻量架构，无外部依赖
- 与现有数据格式完全兼容
- 迁移成本最低

### 2.4 工具库

```typescript
// 核心依赖（生产环境）
{
  "pathe": "^1.1.2"           // 跨平台路径处理
}

// 开发依赖
{
  "@types/node": "^20.10.0",  // Node.js 类型定义
  "pkg": "^5.8.1",           // 打包工具
  "typescript": "^5.3.0",    // TypeScript 编译器
  "vitest": "^1.0.0"         // 测试框架
}
```

## 三、架构设计原则

### 3.1 SOLID 原则应用

- **S (单一职责)**：每个类/模块专注单一功能
  - `SessionManager`：仅负责会话生命周期管理
  - `Storage`：仅负责数据持久化
  - `Recorder`：仅负责记录业务逻辑

- **O (开闭原则)**：通过接口扩展，避免修改现有代码
  - 定义 `Storage` 接口，支持多种存储实现

- **L (里氏替换)**：子类可完全替换父类
  - Hook 处理器统一接口

- **I (接口隔离)**：接口专一，避免胖接口
  - 分离 `ReadableStorage` 和 `WritableStorage`

- **D (依赖倒置)**：依赖抽象而非具体
  - 依赖注入模式

### 3.2 KISS (Keep It Simple, Stupid)

- 避免过度设计
- 优先选择最直观的解决方案
- 代码自解释，减少注释依赖

### 3.3 DRY (Don't Repeat Yourself)

- 提取公共逻辑到工具函数
- 统一 Hook 处理模式
- 共享类型定义

### 3.4 YAGNI (You Aren't Gonna Need It)

- 仅实现当前需要的功能
- 不预留"未来可能用到"的接口
- 删除未使用的代码

## 四、目标平台

### 4.1 支持平台

| 平台 | 架构 | 目标 |
|------|------|------|
| Windows | x64 | `node18-win-x64` |
| Linux | x64 | `node18-linux-x64` |
| macOS | x64 | `node18-macos-x64` |
| macOS | ARM64 | `node18-macos-arm64` |

### 4.2 构建产物

```
bin/
├── session-recorder-win.exe       # Windows 可执行文件
├── session-recorder-linux         # Linux 可执行文件
├── session-recorder-macos-x64     # macOS Intel 可执行文件
└── session-recorder-macos-arm64   # macOS Apple Silicon 可执行文件

hooks-bin/
├── user-prompt-hook.exe           # UserPrompt Hook (Windows)
├── user-prompt-hook               # UserPrompt Hook (Unix)
├── tool-result-hook.exe           # ToolResult Hook (Windows)
├── tool-result-hook               # ToolResult Hook (Unix)
├── session-end-hook.exe           # SessionEnd Hook (Windows)
└── session-end-hook               # SessionEnd Hook (Unix)
```

## 五、非功能需求

### 5.1 性能

- Hook 响应时间 < 100ms
- 单个会话文件 < 100MB
- 启动时间 < 500ms

### 5.2 可维护性

- 完整类型定义
- 模块化架构
- 清晰的代码结构

### 5.3 扩展性

- 插件化设计
- 配置驱动
- 接口抽象

### 5.4 轻量

- 单文件可执行
- 无外部依赖
- 小于 50MB

## 六、技术风险

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| pkg 原生模块兼容性 | 高 | 仅使用纯 JS 模块 |
| stdin/stdout 跨平台差异 | 中 | 统一使用 Node.js API |
| 路径分隔符处理 | 中 | 使用 `pathe` 库 |
| 文件权限问题 | 低 | 构建后自动设置权限 |

## 七、总结

本方案采用 **TypeScript + pkg** 技术栈，实现：

1. ✅ **零 Shell 脚本**：100% TypeScript 实现
2. ✅ **独立可执行**：无需 Node.js 运行时
3. ✅ **跨平台兼容**：Windows/Linux/macOS 统一
4. ✅ **轻量高效**：单文件可执行，无外部依赖
5. ✅ **类型安全**：完整 TypeScript 类型系统
