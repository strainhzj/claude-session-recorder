# TypeScript 迁移实施方案

## 一、项目架构设计

### 1.1 目录结构

```
claude-session-recorder/
├── src/                        # TypeScript 源码
│   ├── core/                   # 核心业务逻辑
│   │   ├── SessionManager.ts   # 会话管理器
│   │   ├── Recorder.ts         # 核心记录器
│   │   └── Storage.ts          # 存储抽象层
│   ├── hooks/                  # Hook 处理器（可执行入口）
│   │   ├── user-prompt-hook.ts      # UserPromptSubmit Hook
│   │   ├── tool-result-hook.ts      # PostToolUse Hook
│   │   └── session-end-hook.ts      # SessionEnd Hook
│   ├── commands/               # 命令实现
│   │   ├── start.ts            # 开始记录
│   │   ├── stop.ts             # 停止记录
│   │   └── view.ts             # 查看会话
│   ├── utils/                  # 工具函数
│   │   ├── path.ts             # 跨平台路径处理
│   │   ├── json.ts             # JSON 处理
│   │   └── logger.ts           # 日志系统
│   ├── types/                  # 类型定义
│   │   ├── session.ts          # 会话类型
│   │   ├── config.ts           # 配置类型
│   │   └── hooks.ts            # Hook 类型
│   ├── scripts/                # 构建脚本
│   │   ├── install.ts          # 安装脚本
│   │   └── build.ts            # 构建脚本
│   └── index.ts                # 主入口（CLI）
├── dist/                       # TypeScript 编译输出
├── bin/                        # 打包后的可执行文件
│   ├── session-recorder-win.exe
│   ├── session-recorder-linux
│   └── session-recorder-macos
├── hooks-bin/                  # Hook 可执行文件
│   ├── user-prompt-hook.exe
│   ├── user-prompt-hook
│   ├── tool-result-hook.exe
│   ├── tool-result-hook
│   ├── session-end-hook.exe
│   └── session-end-hook
├── commands/                   # 命令定义（.md）
│   ├── start-recording.md
│   ├── stop-recording.md
│   └── view-sessions.md
├── skills/                     # 技能定义
│   └── session-management/
│       └── SKILL.md
├── config/                     # 配置文件
│   └── recorder-config.json
├── sessions/                   # 会话数据存储
├── hooks/                      # Hook 配置
│   └── hooks.json
├── tests/                      # 测试文件
│   ├── unit/
│   └── integration/
├── docs/                       # 文档
├── .claude-plugin/             # 插件配置
│   ├── plugin.json
│   └── marketplace.json
├── package.json
├── tsconfig.json
├── pkg.config.js               # pkg 配置
└── README.md
```

### 1.2 架构层次

```
┌─────────────────────────────────────────────────────────┐
│                    Claude Code CLI                      │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│              Hook 可执行文件 (pkg 打包)                  │
│  ┌──────────────────┐  ┌──────────────────┐             │
│  │ user-prompt-hook │  │ tool-result-hook │             │
│  └──────────────────┘  └──────────────────┘             │
│  ┌──────────────────┐                                    │
│  │ session-end-hook │                                    │
│  └──────────────────┘                                    │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                   核心业务逻辑层                         │
│  ┌──────────────────┐  ┌──────────────────┐             │
│  │ SessionManager   │  │    Recorder      │             │
│  └──────────────────┘  └──────────────────┘             │
│  ┌──────────────────┐                                    │
│  │     Storage      │                                    │
│  └──────────────────┘                                    │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│                  JSON 文件存储                           │
│     sessions/conversation-*.json                         │
└─────────────────────────────────────────────────────────┘
```

## 二、核心类型定义

### 2.1 会话类型

```typescript
// src/types/session.ts
export interface Session {
  /** 会话唯一标识 */
  sessionId: string
  /** 会话开始时间 */
  startTime: string
  /** 会话结束时间 */
  endTime: string | null
  /** 用户提示列表 */
  prompts: PromptEntry[]
  /** 响应列表（助手回复和工具结果） */
  responses: ResponseEntry[]
  /** 会话元数据 */
  metadata?: SessionMetadata
}

export interface PromptEntry {
  /** 时间戳 */
  timestamp: string
  /** 提示文本 */
  text: string
}

export interface ResponseEntry {
  /** 响应类型 */
  type: 'assistant' | 'tool'
  /** 助手回复文本 */
  text?: string
  /** 工具名称 */
  toolName?: string
  /** 工具执行结果 */
  result?: string
  /** 时间戳 */
  timestamp: string
}

export interface SessionMetadata {
  /** 会话大小（字节） */
  size: number
  /** 提示数量 */
  promptCount: number
  /** 响应数量 */
  responseCount: number
  /** 最后更新时间 */
  lastUpdated: string
}
```

### 2.2 配置类型

```typescript
// src/types/config.ts
export interface RecorderConfig {
  /** 是否自动开始记录 */
  autoStart: boolean
  /** 存储格式 */
  format: 'json'
  /** 是否包含工具结果 */
  includeToolResults: boolean
  /** 是否包含时间戳 */
  includeTimestamps: boolean
  /** 单个会话最大大小 */
  maxSessionSize: string
  /** 会话保留天数 */
  retentionDays: number
  /** 会话存储目录 */
  sessionsDir: string
  /** 当前会话文件路径 */
  currentSessionFile?: string
}

export const DEFAULT_CONFIG: RecorderConfig = {
  autoStart: true,
  format: 'json',
  includeToolResults: true,
  includeTimestamps: true,
  maxSessionSize: '100MB',
  retentionDays: 90,
  sessionsDir: './sessions'
}
```

### 2.3 Hook 类型

```typescript
// src/types/hooks.ts
export interface HookInput {
  /** 用户提示内容 */
  user_prompt?: string
  /** 工具名称 */
  tool_name?: string
  /** 工具执行结果 */
  tool_result?: string
  /** 其他字段 */
  [key: string]: unknown
}

export interface HookOutput {
  success: boolean
  error?: string
  data?: unknown
}
```

## 三、核心模块实现

### 3.1 存储抽象层

```typescript
// src/core/Storage.ts
import { readFile, writeFile, readdir } from 'fs/promises'
import { join } from 'path'
import type { Session, RecorderConfig } from '../types'

export class Storage {
  constructor(private config: RecorderConfig) {}

  /**
   * 创建新会话
   */
  async createSession(sessionId: string): Promise<Session> {
    const session: Session = {
      sessionId,
      startTime: new Date().toISOString(),
      endTime: null,
      prompts: [],
      responses: []
    }

    await this.writeSession(sessionId, session)
    return session
  }

  /**
   * 加载会话
   */
  async loadSession(sessionId: string): Promise<Session | null> {
    try {
      const content = await readFile(this.getSessionPath(sessionId), 'utf-8')
      return JSON.parse(content)
    } catch {
      return null
    }
  }

  /**
   * 更新会话
   */
  async updateSession(
    sessionId: string,
    updater: (session: Session) => Session
  ): Promise<void> {
    const session = await this.loadSession(sessionId)
    if (!session) {
      throw new Error(`Session ${sessionId} not found`)
    }

    const updated = updater(session)
    await this.writeSession(sessionId, updated)
  }

  /**
   * 列出所有会话
   */
  async listSessions(): Promise<Session[]> {
    const files = await readdir(this.config.sessionsDir)
    const sessionFiles = files.filter(
      f => f.startsWith('conversation-') && f.endsWith('.json')
    )

    const sessions: Session[] = []
    for (const file of sessionFiles) {
      try {
        const content = await readFile(
          join(this.config.sessionsDir, file),
          'utf-8'
        )
        sessions.push(JSON.parse(content))
      } catch {
        // 跳过损坏的文件
      }
    }

    return sessions.sort((a, b) =>
      b.startTime.localeCompare(a.startTime)
    )
  }

  /**
   * 删除会话
   */
  async deleteSession(sessionId: string): Promise<void> {
    const { unlink } = await import('fs/promises')
    await unlink(this.getSessionPath(sessionId))
  }

  /**
   * 写入会话文件
   */
  private async writeSession(sessionId: string, session: Session): Promise<void> {
    await writeFile(
      this.getSessionPath(sessionId),
      JSON.stringify(session, null, 2),
      'utf-8'
    )
  }

  /**
   * 获取会话文件路径
   */
  private getSessionPath(sessionId: string): string {
    return join(this.config.sessionsDir, `conversation-${sessionId}.json`)
  }
}
```

### 3.2 会话管理器

```typescript
// src/core/SessionManager.ts
import { readFile, writeFile, unlink } from 'fs/promises'
import { join, dirname } from 'path'
import { mkdir } from 'fs/promises'
import type { Session, RecorderConfig, PromptEntry, ResponseEntry } from '../types'
import { Storage } from './Storage'

export class SessionManager {
  private currentSessionId: string | null = null
  private storage: Storage
  private statePath: string

  constructor(private config: RecorderConfig) {
    this.storage = new Storage(config)
    this.statePath = join(config.sessionsDir, '../config/.current-session')
  }

  /**
   * 开始新会话
   */
  async startSession(sessionId?: string): Promise<Session> {
    // 确保会话目录存在
    await mkdir(this.config.sessionsDir, { recursive: true })

    const id = sessionId || this.generateSessionId()
    const session = await this.storage.createSession(id)

    this.currentSessionId = id
    await this.saveState(id)
    await this.updateConfig({ currentSessionFile: this.storage['getSessionPath'](id) })

    return session
  }

  /**
   * 结束当前会话
   */
  async endSession(): Promise<void> {
    if (!this.currentSessionId) {
      return
    }

    await this.storage.updateSession(this.currentSessionId, session => ({
      ...session,
      endTime: new Date().toISOString()
    }))

    await this.clearState()
    await this.updateConfig({ currentSessionFile: undefined })
    this.currentSessionId = null
  }

  /**
   * 获取当前会话
   */
  async getCurrentSession(): Promise<Session | null> {
    if (!this.currentSessionId) {
      this.currentSessionId = await this.loadState()
    }

    return this.currentSessionId
      ? this.storage.loadSession(this.currentSessionId)
      : null
  }

  /**
   * 添加用户提示
   */
  async addPrompt(text: string): Promise<void> {
    if (!this.currentSessionId) {
      await this.startSession()
    }

    const entry: PromptEntry = {
      timestamp: new Date().toISOString(),
      text
    }

    await this.storage.updateSession(this.currentSessionId!, session => ({
      ...session,
      prompts: [...session.prompts, entry]
    }))
  }

  /**
   * 添加响应
   */
  async addResponse(entry: ResponseEntry): Promise<void> {
    if (!this.currentSessionId) {
      return
    }

    await this.storage.updateSession(this.currentSessionId!, session => ({
      ...session,
      responses: [...session.responses, entry]
    }))
  }

  /**
   * 列出所有会话
   */
  listSessions(): Promise<Session[]> {
    return this.storage.listSessions()
  }

  /**
   * 生成会话ID
   */
  private generateSessionId(): string {
    const now = new Date()
    const pad = (n: number) => String(n).padStart(2, '0')

    return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`
  }

  /**
   * 保存状态
   */
  private async saveState(sessionId: string): Promise<void> {
    await mkdir(dirname(this.statePath), { recursive: true })
    await writeFile(this.statePath, sessionId, 'utf-8')
  }

  /**
   * 加载状态
   */
  private async loadState(): Promise<string | null> {
    try {
      return await readFile(this.statePath, 'utf-8')
    } catch {
      return null
    }
  }

  /**
   * 清除状态
   */
  private async clearState(): Promise<void> {
    try {
      await unlink(this.statePath)
    } catch {
      // 忽略错误
    }
  }

  /**
   * 更新配置
   */
  private async updateConfig(updates: Partial<RecorderConfig>): Promise<void> {
    const configPath = join(this.config.sessionsDir, '../config/recorder-config.json')
    const current = JSON.parse(await readFile(configPath, 'utf-8'))
    const updated = { ...current, ...updates }

    await writeFile(configPath, JSON.stringify(updated, null, 2), 'utf-8')
  }
}
```

### 3.3 核心记录器

```typescript
// src/core/Recorder.ts
import { readFile, writeFile } from 'fs/promises'
import { join } from 'path'
import type { HookInput, PromptEntry, ResponseEntry } from '../types'

/**
 * 处理用户提示
 */
export async function handleUserPrompt(
  input: HookInput,
  configPath: string
): Promise<void> {
  const prompt = input.user_prompt
  if (!prompt) {
    return
  }

  const config = JSON.parse(await readFile(configPath, 'utf-8'))
  const entry: PromptEntry = {
    timestamp: new Date().toISOString(),
    text: prompt
  }

  await appendEntry('prompts', entry, configPath, config)
}

/**
 * 处理工具结果
 */
export async function handleToolResult(
  input: HookInput,
  configPath: string
): Promise<void> {
  const { tool_name, tool_result } = input
  if (!tool_name || tool_result === undefined) {
    return
  }

  const config = JSON.parse(await readFile(configPath, 'utf-8'))
  const entry: ResponseEntry = {
    type: 'tool',
    toolName: tool_name,
    result: String(tool_result),
    timestamp: new Date().toISOString()
  }

  await appendEntry('responses', entry, configPath, config)
}

/**
 * 处理会话结束
 */
export async function handleSessionEnd(configPath: string): Promise<void> {
  const config = JSON.parse(await readFile(configPath, 'utf-8'))
  const sessionFile = config.currentSessionFile

  if (!sessionFile) {
    return
  }

  const sessionData = JSON.parse(await readFile(sessionFile, 'utf-8'))
  sessionData.endTime = new Date().toISOString()

  await writeFile(sessionFile, JSON.stringify(sessionData, null, 2), 'utf-8')

  // 清除当前会话状态
  config.currentSessionFile = undefined
  await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8')
}

/**
 * 追加条目到会话
 */
async function appendEntry(
  type: 'prompts' | 'responses',
  entry: PromptEntry | ResponseEntry,
  configPath: string,
  config: any
): Promise<void> {
  const sessionFile = config.currentSessionFile

  if (!sessionFile) {
    // 创建新会话
    const sessionId = generateSessionId()
    const sessionsDir = config.sessionsDir || './sessions'
    const { mkdir } = await import('fs/promises')
    await mkdir(sessionsDir, { recursive: true })

    const newSessionFile = join(sessionsDir, `conversation-${sessionId}.json`)

    const newSession = {
      sessionId,
      startTime: new Date().toISOString(),
      endTime: null,
      prompts: type === 'prompts' ? [entry] : [],
      responses: type === 'responses' ? [entry] : []
    }

    await writeFile(newSessionFile, JSON.stringify(newSession, null, 2), 'utf-8')

    config.currentSessionFile = newSessionFile
    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8')
  } else {
    // 追加到现有会话
    const sessionData = JSON.parse(await readFile(sessionFile, 'utf-8'))
    sessionData[type].push(entry)
    await writeFile(sessionFile, JSON.stringify(sessionData, null, 2), 'utf-8')
  }
}

/**
 * 生成会话ID
 */
function generateSessionId(): string {
  const now = new Date()
  const pad = (n: number) => String(n).padStart(2, '0')

  return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`
}
```

## 四、Hook 处理器实现

### 4.1 用户提示 Hook

```typescript
// src/hooks/user-prompt-hook.ts
import { readFileSync } from 'fs'
import { resolve, join, dirname } from 'path'
import { fileURLToPath } from 'url'
import type { HookInput } from '../types'
import { handleUserPrompt } from '../core/Recorder'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

// 获取插件根目录
const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT ||
                   resolve(__dirname, '../..')

async function main() {
  try {
    // 从 stdin 读取 JSON 输入
    const input = readFileSync(0, 'utf-8')
    const data: HookInput = JSON.parse(input)

    // 获取配置路径
    const configPath = join(PLUGIN_ROOT, 'config', 'recorder-config.json')

    // 执行处理
    await handleUserPrompt(data, configPath)

    process.exit(0)
  } catch (error) {
    console.error(JSON.stringify({
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    }))
    process.exit(1)
  }
}

main()
```

### 4.2 工具结果 Hook

```typescript
// src/hooks/tool-result-hook.ts
import { readFileSync } from 'fs'
import { resolve, join, dirname } from 'path'
import { fileURLToPath } from 'url'
import type { HookInput } from '../types'
import { handleToolResult } from '../core/Recorder'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT ||
                   resolve(__dirname, '../..')

async function main() {
  try {
    const input = readFileSync(0, 'utf-8')
    const data: HookInput = JSON.parse(input)

    const configPath = join(PLUGIN_ROOT, 'config', 'recorder-config.json')

    await handleToolResult(data, configPath)

    process.exit(0)
  } catch (error) {
    console.error(JSON.stringify({
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    }))
    process.exit(1)
  }
}

main()
```

### 4.3 会话结束 Hook

```typescript
// src/hooks/session-end-hook.ts
import { join, dirname, resolve } from 'path'
import { fileURLToPath } from 'url'
import type { HookInput } from '../types'
import { handleSessionEnd } from '../core/Recorder'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const PLUGIN_ROOT = process.env.CLAUDE_PLUGIN_ROOT ||
                   resolve(__dirname, '../..')

async function main() {
  try {
    const configPath = join(PLUGIN_ROOT, 'config', 'recorder-config.json')

    await handleSessionEnd(configPath)

    process.exit(0)
  } catch (error) {
    console.error(JSON.stringify({
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    }))
    process.exit(1)
  }
}

main()
```

## 五、构建配置

### 5.1 TypeScript 配置

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "bin", "hooks-bin"]
}
```

### 5.2 pkg 配置

```javascript
// pkg.config.js
export default {
  entry: 'src/index.ts',
  targets: [
    'node18-win-x64',
    'node18-linux-x64',
    'node18-macos-x64',
    'node18-macos-arm64'
  ],
  output: 'bin/',
  options: ['esm'],
  assets: ['config/**/*'],
  scripts: ['dist/**/*.js'],
  minify: true,
  clean: true
}
```

### 5.3 package.json

```json
{
  "name": "claude-session-recorder",
  "version": "2.0.0",
  "description": "Claude Code CLI Session Recorder - TypeScript 实现",
  "type": "module",
  "main": "dist/index.js",
  "bin": {
    "session-recorder": "./bin/session-recorder"
  },
  "scripts": {
    "build": "tsc",
    "build:hooks": "tsc src/hooks/*.ts --outDir dist/hooks",
    "package": "npm run build && npm run package:hooks",
    "package:hooks": "pkg src/hooks/user-prompt-hook.ts --targets node18-win-x64,node18-linux-x64,node18-macos-x64 --output hooks-bin/user-prompt-hook && pkg src/hooks/tool-result-hook.ts --targets node18-win-x64,node18-linux-x64,node18-macos-x64 --output hooks-bin/tool-result-hook && pkg src/hooks/session-end-hook.ts --targets node18-win-x64,node18-linux-x64,node18-macos-x64 --output hooks-bin/session-end-hook",
    "package:all": "npm run package && pkg . --targets node18-win-x64,node18-linux-x64,node18-macos-x64 --output bin/session-recorder",
    "install-hooks": "node dist/scripts/install.js",
    "dev": "tsc --watch",
    "test": "vitest"
  },
  "dependencies": {
    "pathe": "^1.1.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "pkg": "^5.8.1",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0"
  },
  "pkg": {
    "scripts": ["dist/**/*.js"],
    "assets": ["config/**/*"],
    "targets": [
      "node18-win-x64",
      "node18-linux-x64",
      "node18-macos-x64"
    ],
    "outputPath": "bin"
  }
}
```

## 六、实施时间表

| 阶段 | 任务 | 工时 | 交付物 |
|------|------|------|--------|
| **第1周** | 项目初始化 + 类型定义 | 2天 | TypeScript 项目骨架 |
| | 核心 Recorder 实现 | 3天 | 会话记录功能 |
| **第2周** | Hook 处理器实现 | 2天 | 三个 Hook 可执行文件 |
| | pkg 打包配置 | 2天 | 构建系统 |
| | 跨平台测试 | 1天 | 测试报告 |
| **第3周** | 命令层迁移 | 2天 | TypeScript 命令 |
| | 安装脚本 | 1天 | 自动化安装 |
| | 集成测试 | 2天 | 完整测试套件 |
| **第4周** | 文档编写 | 1天 | README 和文档 |
| | 性能优化 | 2天 | 优化报告 |
| | 发布准备 | 2天 | Release |

**总计：4周**
